OrgChart Plan — Hello-World (Detailed)

Overview
--------
This document captures a detailed plan for the OrgChart Canvas + Web Worker MVP in the Hello-World app. It is intentionally self-contained so it can be consulted later without having to scan code.

Goals (MVP)
- Display top-level roots (profiles with no manager) and shallow descendants (default depth=2).
- Canvas-based rendering with Web Worker layout for responsiveness up to 2,000 nodes.
- Lazy loading of deeper subtrees on expand; avatars via `AvatarStore.getImage(node.id)`.
- Zoom & Level-of-Detail thresholds controlled by CSS variables for quick tuning.
- All logged-in users can view the chart.

High-level Flow
---------------
1. User clicks the first toolbar button.
2. The toolbar button listener calls `orgchart_init.open()`.
3. `orgchart_init.open()` mounts `containers/orgchart/orgchart.html` into `#main-container` and displays the canvas container.
4. `orgchart_init` requests `/api/orgchart/subtree?max_depth=2` (no root_id) to retrieve top-level roots and children (server enforces `max_nodes=2000`).
5. On response, `orgchart_init` spawns a Web Worker (`worker-layout.js`) and posts a `layout:init` message containing nodes, edges, and layout options.
6. Worker computes a deterministic tree layout (BFS level assignment, simple subtree width for X spacing) and posts `layout:result` with coordinates and bounding boxes per node.
7. Main thread receives layout result and forwards it to `orgchart_renderer`, which draws the graph into a single `<canvas>` using a transform matrix for pan/zoom.
8. Renderer applies LOD rules (based on zoom) to draw dots, initials, avatars+names, or avatars+details.
9. User interactions: pan/zoom, node click (center + open `user_profile`), expand node (calls API for that node, merges new nodes, sends incremental layout request to worker), close (unmount + terminate worker).

Data Contracts
--------------
API response (JSON):
{
  nodes: [
    { id, first_name, last_name, avatar_url, email, title, reports_to_id }
  ],
  edges: [ { from_id, to_id } ]
}

Worker message protocol (main → worker)
- { type: "layout:init", nodes, edges, options }
- { type: "layout:computeSubtree", rootId, maxDepth }
- { type: "layout:cancel" }

Worker message protocol (worker → main)
- { type: "layout:result", nodes: [ { id, x, y, width, height } ], edges, meta }
- { type: "layout:error", message }

LOD thresholds & CSS variables
- CSS variables (exposed to tune behavior):
  --orgchart-zoom-default: 1.1;
  --orgchart-lod-dot: 0.5;
  --orgchart-lod-initials: 0.5;
  --orgchart-lod-avatar32: 1.0;
  --orgchart-lod-avatar64: 1.5;
  --orgchart-avatar-size-small: 32px;
  --orgchart-avatar-size-large: 64px;
  --orgchart-vertical-spacing: 120px;
  --orgchart-horizontal-spacing: 30px;

LOD rendering policy (MVP):
- zoom < 0.5: draw only color dots.
- 0.5 ≤ zoom < 1.0: draw initials in color circles.
- 1.0 ≤ zoom < 1.5: draw 32px avatar + full name.
- zoom ≥ 1.5: draw 64px avatar + full name + additional details.

Server-side constraints
----------------------
- Enforce `max_nodes=2000` per request and `max_depth` default 2 to keep payloads reasonable.
- Use `WITH RECURSIVE` on `relationships` to fetch subtree with cycle-protection (visited tracking) and depth-limit.
- Add indexes on `relationships.from_id` and `relationships.to_id`.
- Endpoint requires an authenticated session (all logged-in users allowed).
- SUPABASE_SERVICE_KEY is available.

Implementation Steps (detailed)
-------------------------------

1. Add files, or update existing ones (read the repo in order to check what already exists):
   - `containers/orgchart/orgchart.html`
   - `containers/orgchart/orgchart_styles.css`
   - `containers/orgchart/orgchart_init.js`
   - `containers/orgchart/orgchart_renderer.js`
   - `containers/orgchart/worker-layout.js`
   - `api/orgchart/subtree.js`
Existing (found in repo):
orgchart.html
orgchart_styles.css
orgchart_init.js
orgchart_renderer.js
worker-layout.js
subtree.js
subtree.json (fixture)
Migrations already present:
001_create_profiles.sql
002_extend_profiles.sql
003_add_role_column.sql
004_create_manager_requests.sql
005_add_fk_manager_requests_profiles.sql
006_add_title_column.sql

2. Wire `index.html` to load `orgchart_init.js` script (so module can register itself early and attach toolbar binding).
3. Implement `orgchart_init.open()` / `close()` and expose window-level API used by toolbar binding.
4. Implement worker layout: BFS, level assignment, compute subtree widths, place siblings next to each other, return bounding boxes.
5. Implement renderer: canvas `requestAnimationFrame` loop, transform, LOD checks, avatar cache (LRU), hit-testing by bounding boxes, expand API.
6. Implement API endpoint with Supabase service-role client if `SUPABASE_SERVICE_KEY` is available; otherwise return an error or a safe fixture.
7. Add i18n keys and use `getString()` for toolbar and close button.
8. Test with fixture dataset (small), then test with larger synthetic dataset up to 2,000 nodes for rendering time profiling.
9. Iterate on spacing & LOD thresholds by changing CSS variables.

How edges are represented, drawn, styled, and interacted with in the OrgChart UI.
---------------------------------------------------------------------------------

1.Data / Payload
-One-per-employee: API returns at most one edge per from_id (latest manager_requests row).
-Node coords: worker returns node bounding boxes/anchor points; renderer uses those anchors to build edge paths.

2.Visual Style Mapping
-Status → style: accepted → solid black stroke; pending → dashed red stroke; declined → solid red stroke.
-Stroke & weight: base stroke ~1.5px (scale with DPR).
-no Badges
-Color tokens: use CSS variables (--orgchart-edge-accepted, --orgchart-edge-pending, --orgchart-edge-declined) so themes can change easily.

3.Path / Layout Algorithm
dominant diagram flow top→down.
Two vertex (orthogonal) connectors: prefer vertical-then-horizontal-then-vertical polylines for clarity in trees: start at manager bottom-center → vertical to mid-y → horizontal to child x → vertical to child top-center.
Routing hints: worker supplies sibling ordering and subtree widths so renderer can compute elbow X offsets deterministically.
Use garbage\edge.html for reference.

4.Rendering & Performance
Separate layers: draw edges on a background canvas layer, nodes on top; this lets you re-render edges independently from nodes.
Batching: group same-style edges into single path draws to reduce canvas state changes.
On overlaping segments, draw black segment.
Offscreen / worker-friendly: heavy path math in worker if needed; actual canvas drawing on main thread. Use OffscreenCanvas when supported.
Pixel scaling: multiply canvas size by devicePixelRatio; scale stroke widths accordingly.
Culling: skip drawing edges completely outside the current viewport; use node bounding boxes for quick visibility tests.
Interaction & State Changes.
Have the worker compute routing hints.

5.Hover/Focus: No hover highlights
Click: No clicking
Animated updates: on subtree expand/merge, animate edge morphs (short fade+translate) to visually connect new nodes without heavy layout churn.
Accessibility & UX


Database Schema & Migrations
----------------------------

TL;DR: For the MVP add a nullable `reports_to_id` FK column to `profiles`, index it, backfill from the latest accepted
`manager_requests` rows in an idempotent, audited way, update `api/orgchart/subtree.js` to derive `edges`
from that column (manager → report), and include a reversible migration, tests, and a safe rollout/rollback
procedure.

- Migration file: create `migrations/007_add_reports_to_column.sql` with an `UP` that:
  - adds `reports_to_id INTEGER` (nullable) to `profiles`,
  - adds `REFERENCES profiles(id) ON DELETE SET NULL`, and
  - creates an index on `profiles.reports_to_id`.
  - The `DOWN` must drop the index then drop the column (exact reverse) so rollback is clean.

- Backfill policy (manual / idempotent):
  - Authoritative source: the latest `manager_requests` row per employee regardless of the status.
  - Backfill updates only when necessary (e.g., `profiles.reports_to_id IS NULL` or per an explicit
    overwrite policy). Run updates in small transactional batches, guarded by an advisory lock.
  - Record changed rows in an audit table such as `orgchart_backfill_log` or create a one-time
    `orgchart_profiles_backup` snapshot for the affected rows to enable easy rollback.
  - Detect anomalies (self-reference, conflicts, cycles) and surface them for manual review rather
    than blindly overwriting.

- API update (`api/orgchart/subtree.js`):
  - Derive `edges` as `{ from_id: profiles.reports_to_id, to_id: profiles.id }` when
    `reports_to_id IS NOT NULL`.
  - Implement subtree fetch with `WITH RECURSIVE` that tracks a `visited` set to prevent cycles,
    enforces `max_depth` and `max_nodes` at the API layer, and returns `nodes` (including
    `reports_to_id`) and `edges` in the existing response shape.

- Indexes & query plan verification:
  - Ensure index on `profiles.reports_to_id` exists. After backfill run `ANALYZE` and `EXPLAIN`
    the recursive subtree query with representative parameters to confirm index usage and
    acceptable planning cost.

- Data safety & constraints:
  - Optionally add a lightweight CHECK or trigger to prevent `reports_to_id = id` (low risk).
  - Prefer detection + manual remediation for complex cycles.

- Testing & rollout checklist:
  - Preflight on staging (snapshot), run migration + backfill, verify `api/orgchart/subtree` outputs
    expected roots and edges.
  - Production rollout: take DB backup/snapshot, run migration + backfill during a low-traffic window,
    run smoke tests, and monitor. Rollback via migration `DOWN` or restore changed rows from the
    backup/audit table as needed.

- Migration → Option B path:
  - Keep this migration minimal so a future migration that normalizes `reports_to_id` into a
    `relationships` table is straightforward (preserve `reports_to_id` as the authoritative view
    until the controlled migration copies it into `relationships`).

This section implements the TL;DR and steps discussed for Option A (MVP). If you want, I can now
generate the exact reversible SQL for `migrations/007_add_reports_to_column.sql` and the idempotent,
bedded backfill SQL (batched + advisory-lock guarded), plus PowerShell-friendly `psql` commands
to run the backfill interactively.

